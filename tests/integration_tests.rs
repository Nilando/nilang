use std::fs::File;
use std::path::Path;
use std::process::Command;

fn integration_test_runner(program_name: &str, expected_status: bool) {
    let update_mode: bool = std::env::var("UPDATE_TESTS").is_ok();
    if update_mode {
        update_integration_test(program_name, expected_status);
        return;
    }

    let project_root = std::env!("CARGO_MANIFEST_DIR");
    let expected_ast = format!("{}/tests/fixtures/expected_ast/{}.json", project_root, program_name);
    let generated_ast = format!("{}/tests/fixtures/generated_ast/{}.json", project_root, program_name);
    let expected_bytecode = format!("{}/tests/fixtures/expected_bytecode/{}.json", project_root, program_name);
    let generated_bytecode = format!("{}/tests/fixtures/generated_bytecode/{}.json", project_root, program_name);
    let expected_output = format!("{}/tests/fixtures/expected_output/{}.txt", project_root, program_name);
    let generated_output = format!("{}/tests/fixtures/generated_output/{}.txt", project_root, program_name);
    let expected_error = format!("{}/tests/fixtures/expected_error/{}.txt", project_root, program_name);
    let generated_error = format!("{}/tests/fixtures/generated_error/{}.txt", project_root, program_name);
    let program = format!("{}/tests/programs/{}.nl", project_root, program_name);

    std::fs::create_dir_all(Path::new(&generated_ast).parent().unwrap()).expect("failed to create dir");
    std::fs::create_dir_all(Path::new(&generated_bytecode).parent().unwrap()).expect("failed to create dir");
    std::fs::create_dir_all(Path::new(&generated_output).parent().unwrap()).expect("failed to create dir");
    std::fs::create_dir_all(Path::new(&generated_error).parent().unwrap()).expect("failed to create dir");

    let generated_output_file = File::create(&generated_output).expect("Failed to create file");
    let generated_error_file = File::create(&generated_error).expect("Failed to create file");
    let args = ["-a", &generated_ast, "-b", &generated_bytecode, &program];
    let status = Command::new("./target/debug/nilang")
        .args(args)
        .stdout(generated_output_file)
        .stderr(generated_error_file)
        .status()
        .expect("Failed to execute command");

    assert!(status.success() == expected_status, "Unexpected return status");

    let expected_ast = std::fs::read_to_string(&expected_ast).expect("Failed to read expected file");
    let generated_ast = std::fs::read_to_string(&generated_ast).expect("Failed to read output file");
    assert!(generated_ast == expected_ast, "Generated AST does not match fixture");

    let expected_bytecode = std::fs::read_to_string(&expected_bytecode).expect("Failed to read expected file");
    let generated_bytecode = std::fs::read_to_string(&generated_bytecode).expect("Failed to read output file");
    assert!(generated_bytecode == expected_bytecode, "Generated bytecode does not match fixture");

    let expected_output = std::fs::read_to_string(&expected_output).expect("Failed to read expected file");
    let generated_output = std::fs::read_to_string(&generated_output).expect("Failed to read output file");
    assert!(generated_output == expected_output, "Generated output does not match fixture");

    let expected_error = std::fs::read_to_string(&expected_error).expect("Failed to read expected file");
    let generated_error = std::fs::read_to_string(&generated_error).expect("Failed to read output file");
    assert!(generated_error == expected_error, "Generated error does not match fixture");
}

fn update_integration_test(program_name: &str, expected_status: bool) {
    let project_root = std::env!("CARGO_MANIFEST_DIR");
    let expected_ast = format!("{}/tests/fixtures/expected_ast/{}.json", project_root, program_name);
    let expected_bytecode = format!("{}/tests/fixtures/expected_bytecode/{}.json", project_root, program_name);
    let expected_output = format!("{}/tests/fixtures/expected_output/{}.txt", project_root, program_name);
    let expected_error = format!("{}/tests/fixtures/expected_error/{}.txt", project_root, program_name);
    let program = format!("{}/tests/programs/{}.nl", project_root, program_name);
    let expected_output_file = File::create(&expected_output).expect("Failed to create file");
    let expected_error_file = File::create(&expected_error).expect("Failed to create file");
    let args = ["-a", &expected_ast, "-b", &expected_bytecode, &program];
    let status = Command::new("./target/debug/nilang")
        .args(args)
        .stdout(expected_output_file)
        .stderr(expected_error_file)
        .status()
        .expect("Failed to execute command");

    assert!(status.success() == expected_status, "Unexpected return status");
}

#[test]
fn test_hello_world() {
    integration_test_runner("hello_world", false);
}
